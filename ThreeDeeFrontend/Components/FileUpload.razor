@using System.Diagnostics
@inject IWebHostEnvironment Environment
@inject ISnackbar Snackbar
@attribute [Authorize]

@if (_isUploading)
{
    <MudButton Variant="Variant.Filled" Color="Color.Error" OnClick="Callback">CANCEL UPLOAD</MudButton>
}
else
{
    <MudFileUpload T="IBrowserFile" FilesChanged="async f => await UploadFiles(f)" MaximumFileCount="1" Style="margin: 0;">
        <ButtonTemplate>
            <MudButton HtmlTag="label"
                       Variant="Variant.Text"
                       StartIcon="@Icons.Material.Filled.CloudUpload"
                       for="@context">
                Upload Files
            </MudButton>
        </ButtonTemplate>
    </MudFileUpload>
}

@code
{
    [Parameter]
    public EventCallback<int> UploadStateHasChanged { get; set; }
    IList<IBrowserFile> _files = new List<IBrowserFile>();
    private int _maxAllowedSize = 1024 * 1024 * 1024;

    private async Task UploadFiles(IBrowserFile file)
    {
        _files.Clear();
        var path = Path.Combine(Environment.ContentRootPath,
            "unsafe_uploads", file.Name);
        if (File.Exists(path))
        {
            Snackbar.Add($"File with name {file.Name} alrady exists. Upload cancelled. Please rename your file first and retry.", Severity.Warning);
            return;
        }
        await using FileStream writeStream = new(path, FileMode.Create);
        await using var readStream = file.OpenReadStream(_maxAllowedSize);
        var buffer = new byte[1024 * 10];
        long totalSize = readStream.Length;
        long totalRead = 0;
        long percentCache = 0;
        try
        {
            _isUploading = true;
            bool isViewUpdateRequested = false;
            var sw = Stopwatch.StartNew();
            int bytesRead;
            while ((bytesRead = await readStream.ReadAsync(buffer)) != 0)
            {
                if (_forceStop)
                {
                    break;
                }
                await writeStream.WriteAsync(buffer, 0, bytesRead);
                totalRead += bytesRead;

                if (isViewUpdateRequested == false)
                {
                    if (sw.ElapsedMilliseconds > 1000)
                    {
                        sw.Stop();
                        isViewUpdateRequested = true;
                    }
                }
                else
                {
                    int percentComplete = (int)((double)totalRead / totalSize * 100);
                    if (percentComplete % 1 == 0 && percentComplete != percentCache)
                    {
                        percentCache = percentComplete;
                        await UploadStateHasChanged.InvokeAsync(percentComplete);
                    }
                }
            }
        }
        catch (Exception e)
        {
            Snackbar.Add($"Upload of {file.Name} failed.", Severity.Error);
        }
        
        if (_forceStop == false)
        {
            _files.Add(file);
            Snackbar.Add($"{file.Name} uploaded successfully.", Severity.Success);
        }
        else
        {
            writeStream.Close();
            await writeStream.DisposeAsync();
            File.Delete(path);
            _forceStop = false;
            Snackbar.Add($"Upload of {file.Name} cancelled.", Severity.Info);
        }
        _isUploading = false;
        await UploadStateHasChanged.InvokeAsync(0);
    }

    private bool _forceStop;
    private bool _isUploading;

    private void Callback()
    {
        _forceStop = true;
    }

    protected override void OnInitialized()
    {
        Snackbar.Configuration.PositionClass = Defaults.Classes.Position.BottomCenter;

    }
}